Tmin = W.raw$TMIN/10
Tmax = W.raw$TMAX/10
# Put all reformated data into a new data table
temps = data.frame(Date, Tmean, Tmin, Tmax)
# Calculate the delta T value or the difference between Tmax and Tmin
# for use in the Evaporation/Evapotranspiration equation
D.T = Tmax-Tmin
# Read in prcp data and convert to meters
w.prcp = W.raw$PRCP/1000
###########################################################
# Read in Individual wetland parameters #
###########################################################
setwd("C:/Users/Alex Looi/Desktop/Watersheds")
# Read in the data table that had additional parameters for modeling
# each wetland site. This includes parameters such as, plank heights
# that depend on the season, starting water level height, weir
# length, and the area of Typha and Open water
w.parms = read.table("Wetland Parameters.csv", sep = ",", header = T)
row.names(w.parms) = w.parms$X
w.parms = w.parms[,-1]
site.parms = w.parms[which(site.abv == row.names(w.parms)),]
for (s in 3:12){
assign(names(site.parms)[s], site.parms[s])
}
# is there a WCS? additional parameters if there is a WCS (is.WCS)
is.WCS = as.logical(is.WCS)
p.h = as.numeric(p.h) # starting plank height (p.h)
L = as.numeric(L) # width of weir, in feet (L)
s.ph = as.numeric(s.ph) # in June/summer an extra plank is added (s.ph)
f.ph = as.numeric(f.ph) # in the fall ~Oct, the plank is removed (f.ph)
i.WL = as.numeric(i.WL) # initial water level (i.WL)
AOW = as.numeric(AOW) # Area of the open water in the wetland (AOW)
AT = as.numeric(AT) # Area of the typha in 10,000ths of square meters (AT)
tot.A = AT + AOW # Total wetland Area (tot.A)
i.P = as.numeric(i.P)
i.N = as.numeric(i.N)
#########################################################
# Read in Water level vs. volume relationship #
#########################################################
setwd("C:/Users/Alex Looi/Desktop/Watersheds/Wetland Sites")
Site.dir = list.files(pattern = Site.name)
dir = paste("C:/Users/Alex Looi/Desktop/Watersheds/Wetland Sites/",
Site.dir, sep = "")
setwd(dir)
file = paste(site.abv, "Vol vs WL.csv")
WLvsVol = read.table(file, sep = ",", header = T)
# Read in Linear Regression parameters #
#########################################################
# Note that this relationship is only for wetlands that
# DO NOT have a WCS. This is because wetlands with a
# WCS is essentially "decoupled" from the River.
setwd("C:/Users/Alex Looi/Desktop/Watersheds")
lm.parms = read.table("Waterlevel lm parameters.csv",
header = T, sep = ",")
row.names(lm.parms) = lm.parms$X
lm.parms = lm.parms[,-1]
#########################################################
# Evapotranspiration Parameters #
#########################################################
# Crop Coefficients For each season
# For Typha
K_c = c(0, 0.4, 1.2, 0.4)
# Winter, Spring, Summer, Fall
# Mean daylength times for each month at the 44th degree North Lat.
# The vector starts in Jan and ends December
R_a = c(9.1, 10.3, 11.6, 13.2, 14.6, 15.3, 15.0, 13.8, 12.3, 10.7, 9.4, 8.7)
# these are conversion numbers to convert mm per day per hectare to m^3 per day
mm.to.m = 1/1000 # millimeters to meters conversion (0.001 per meter)
hec.to.m = 10000 # hectares to meters squared conversion (10,000 m^2 to hectare)
dir = paste("C:/Users/Alex Looi/Desktop/Watersheds/Wetland Sites/",
Site.dir, "/Output", sep = "")
setwd(dir)
##########################################################
# Snowmelt Parameters #
##########################################################
# when Tmean greater than 0
# Q(n+1) = K_b*Qn + (1-K_b)*(SMC*Tmean*tot.A+Prcp)
# Baseflow recession constant (unitless)
K_b = 0.924
# Snow melt constant
SMC = 0.0045 # meters*(Celcius^-1)*(day^-1)
# Read in GLWF inputs #
###################################################################
# These inputs are developed from GWLF, the Mapshed plugin for GIS
# Find the file name in the folder (all files have the pattern Dayflow
# for all sites).
GWLF.input = list.files(pattern = "DayFlow")
model.input = read.table(GWLF.input, header = T, sep = ",")
model.colnames = names(model.input)
# Take only the Nutrient input from GWLF watershed model results
# numbers should only be in Kg.
TP.kg = model.input$TP..kg.
TN.kg = model.input$TN..kg.
# Conversion factor: Kilograms to grams
kg.to.g = 1000
#Conversion factor: Moles to Micro-moles
M.to.uM = 1000000
# Conversion factor for converting Mass (grams) to moles
P.MM = 30.97376
N.MM = 14.00728
# Units as is are in m^3 need to convert to kg/L
# (there are 1000 Liters in 1 m^3)
m3.to.L = 1000
# Give daily inflow its own variable
Daily.inflow = model.input$Daily.Flow..m.3
# The nutrient concentration of P in the St. Lawrence River
SLR.nut.P
# The nutrient concentration of N in the St. Lawrence River
SLR.nut.N
# Read in ABay Water Levels Data needed
#########################################################
setwd("C:/Users/Alex Looi/Desktop/Watersheds/WL Data/ABay Daily Mean")
ABayWL.file = list.files(pattern = "Model")
ABay.WL = read.table(ABayWL.file, sep = ",", header = T)
# Convert the variable type of
Dates = as.character(ABay.WL$Date)
Dates = as.POSIXlt(Dates, format = "%m/%d/%Y")
M = format(Dates , "%m")
#########################################################
# The following are vectors are used to estimate losses #
# and gains of water in the wetland.                    #
#########################################################
# the total water volume for the next day
nd.vol = rep(0, length(ABay.WL[,1]))
# The total water level for the next day
nd.WL = rep(0, length(ABay.WL[,1]))
# Water level at each time step
s.WL = rep(0, length(ABay.WL[,1]))
# Total volume of water flowing out at each time step
outflow = rep(0, length(ABay.WL[,1]))
# the dilution rate at each time step
delta = rep(0, length(ABay.WL[,1]))
# volume of water in the wetland at each time step
peak.vol = rep(0, length(ABay.WL[,1]))
# Peak water level in the wetland at each time step
peak.WL = rep(0, length(ABay.WL[,1]))
# Potential Evapotation each day off the surface water of the wetland
EV = rep(0, length(ABay.WL[,1]))
PEV = rep(0, length(ABay.WL[,1]))
# Evapotransporation each day by Typha each day out of the wetland
ET = rep(0, length(ABay.WL[,1]))
# Precipitation (includes rain and snow) that falls on the wetland
# every day.
m.prcp = rep(0, length(ABay.WL[,1]))
# Snow accumuluation on the wetland, this will be in melted
# equivalent rainfall (mm)
S.accu = rep(0, (length(ABay.WL[,1])+1))
# The amount of water back flowing into the wetland from the
# creek/St. Lawrence River
w.influx = rep(0, length(ABay.WL[,1]))
# the total amount of water that has flowed out of the wetland
# over the course of the entire simulation
w.outflux = rep(0, length(ABay.WL[,1]))
# The total amount of water that has flowed out of the wetland
# the time step before the current
iw.outflux = 0
# A vector used for debugging.
logic.flow = rep(F, length(ABay.WL[,1]))
################################################################
# Variables to model the nutrient concentration in the wetland #
################################################################
# The following code sets up vectors to log concentrations of nutrients
# or amounts of water depending on the time step.
#########################################
# Phosphorus Variables #
#########################################
P.conc = rep(0, length(ABay.WL[,1])) # Phosphorus concentration in Kg/L
P.tot = rep(0, length(ABay.WL[,1])) # Total Phosphorus in wetland
i.P.conc = 0 # initial P concentration for each time step in Kg/L
i.P.tot = 0 # initial total P in Kg for each time step
# total mass of P back flowing into the wetland from the creek
P.influx = rep(0, length(ABay.WL[,1]))
# Phosphorus molarity of surface waters in wetland
P.molarity = rep(0, length(ABay.WL[,1]))
# total amount of P that has been exported by the system
P.outflow = rep(0, length(ABay.WL[,1]))
# The next day's total P after an out flow event
nd.P.tot = rep(0, length(ABay.WL[,1]))
# The initial total amount of phosphorus in a wetland
iP.tot.exp = 0
# The total amount of the exported P (P and water that has
# accummulated over the course of the simulation)
P.tot.exp = rep(0, length(ABay.WL[,1]))
# The concentration of the exported P (P and water that has
# accummulated over the course of the simulation)
P.exp.conc = rep(0, length(ABay.WL[,1]))
# the next day's P concentration after an outflow event
nd.P.conc = rep(0, length(ABay.WL[,1]))
# The influx of P into the wetland (total P)
P.influx = rep(0, length(ABay.WL[,1]))
###########################################################
# Nitrogen Variables #
###########################################################
N.conc = rep(0, length(ABay.WL[,1])) # Nitrogen concentration in Kg/L
N.tot = rep(0, length(ABay.WL[,1])) # Total Nitrogen in wetland
i.N.conc = 0 # initial N concentration for each time step in Kg/L
i.N.tot = 0 # initial total N in Kg for each time step
# total mass of N back flowing into the wetland from the creek
N.influx = rep(0, length(ABay.WL[,1]))
# Nitrogen molarity of surface waters in wetland
N.molarity = rep(0, length(ABay.WL[,1]))
# total amount of N that has been exported by the system
N.outflow = rep(0, length(ABay.WL[,1]))
# The next day's total N after an out flow event
nd.N.tot = rep(0, length(ABay.WL[,1]))
# The initial total amount of nitrogen in a wetland
iN.tot.exp = 0
# The total amount of the exported N (N and water that has
# accummulated over the course of the simulation)
N.tot.exp = rep(0, length(ABay.WL[,1]))
# The concentration of the exported N (N and water that has
# accummulated over the course of the simulation)
N.exp.conc = rep(0, length(ABay.WL[,1]))
# the next day's N concentration after an outflow event
nd.N.conc = rep(0, length(ABay.WL[,1]))
# The influx of N into the wetland (total P)
N.influx = rep(0, length(ABay.WL[,1]))
################################################################
# Parameters for LM ABay vs. Site
################################################################
M = lm.parms$DB[1]
B = lm.parms$DB[2]
# Capital "M" is the slope in the linear model for each wetland without a
# water control structure, used to calculate the water level based on
# A Bay water level. This is not to be confused with lower case "m" which
# stands for month, and is used in determining the crop coefficient.
################################################################
# find the next day's water level using a LR.
# If the site is not PT. This is because
# PT follows the water level dynamics of the river
################################################################
if(site.abv != "PT"){
nd.WL = round(M*ABay.WL$IGLD.m+B, 3)
} else if (site.abv == "PT") {
nd.WL = round(ABay.WL$IGLD.m, 3)
}
# Initial Conditions
# This calculates the initial volume for the wetlands given a
# particular starting/initial water level.
if(is.WCS){
s.WL[1] = i.WL
i.vol = WLvsVol$vol[which(i.WL == WLvsVol$WLs)]
} else {
# Wetlands without WCS have starting water levels based on
# the starting water level in ABay. (is this really necessary?).
i.WL = round(M*ABay.WL$IGLD.m[1]+B, 3)
i.vol = WLvsVol$vol[which(i.WL == WLvsVol$WLs)]
s.WL[1] = i.WL
}
# Other Parameters
n.days = length(ABay.WL[,1])
# Initialize the initial total nutrients (N and P) for the wetland
i.P.conc = i.P
i.N.conc = i.N
i.P.tot = i.P.conc*i.vol
i.N.tot = i.N.conc*i.vol
for(d in 1:n.days){
# Grab Just the months from the date class
m = format(Dates[d], "%m")
# Find the mean day length for the given month
R_a.m = R_a[as.numeric(m)]
# Find the appropriate K_c value for the season
if(m == "12" || m == "01" || m == "02")K_c.s = K_c[1]
if(m == "03" || m == "04" || m == "05")K_c.s = K_c[2]
if(m == "06" || m == "07" || m == "08")K_c.s = K_c[3]
if(m == "09" || m == "10" || m == "11")K_c.s = K_c[4]
# If the temperature is below zero degrees C assume prcp is
# frozen and sits on top of the wetland.
if(Tmean[d] > 0){
# total water volume input from snow melt and precipitation
m.prcp[d] = (SMC*Tmean[d]*S.accu[d] + w.prcp[d]*tot.A)
# subtract the melted snow from the total accumulated snow
S.accu[d+1] = S.accu[d] - SMC*Tmean[d]*S.accu[d]
# Make sure that if the accumulated snow goes below zero
# (negative) accumulated snow goes back to zero
if(S.accu[d] < 0) S.accu[d] = 0
} else { # if the temperature is below zero prcp falls as snow
# and doesn't melt. Accumulate snow if there is snow
# present already
S.accu[d+1] = w.prcp[d]*tot.A + S.accu[d]
}
# Calculate the potential Evaporation
# if the difference between Tmin and Tmax is less than 0
# there is no evaporation or evapotranspiration
if(D.T[d] <= 0){
PEV[d] = 0
} else {
# Potential evaporation using Hargreaves equation
PEV[d] = 0.0023*(Tmean[d]+17.8)*(D.T[d]^0.5)*R_a.m
}
# Calculate the potential Evapotranspiration
ET[d] = PEV[d]*K_c.s
# Convert EV and ET from mm/day/hectares to m^3/day
# Make the conversion from mm per day per hectare to meters^3
# then multiply by area of surface Water
# multiply by area of typha
EV[d] = PEV[d]*mm.to.m*AOW
ET[d] = ET[d]*mm.to.m*AT
# Calculate what the "peak volume" in
# the wetland would be for the Current day.
# add in any snow melt and precipitation
# subtract and evapotranspiration or evaporation
peak.vol[d] = i.vol + Daily.inflow[d] + m.prcp[d] - ET[d] - PEV[d]
# Calculate the total amount of nutrients in the wetland before
# the "outflow event".
P.tot[d] = TP.kg[d] + i.P.tot
N.tot[d] = TN.kg[d] + i.N.tot
# Calculate the peak nutrient concentration in the wetland
P.conc[d] = P.tot[d]/peak.vol[d]
N.conc[d] = N.tot[d]/peak.vol[d]
# for the Scenario that the wetland has a water control structure
if (is.WCS){
# vector value that matches peak volume
# with the WL in the wetland
pWL.vec = which.min(peak.vol[d] >= WLvsVol$vol)
# find the peak Water level using the vector value.
peak.WL[d] = WLvsVol$WLs[pWL.vec]
# if the month is jun, jul, aug, sep, or oct.
# there is an extra plank
if (m == "06" || m == "07"|| m == "08" || m == "09" || m == "10"){
# the height of the planks on the WCS
p.H = s.ph
} else {
# the height of the planks on the WCS
p.H = f.ph
}
# Find the head height of the water
# Convert to feet from meters
H = (peak.WL[d] - p.H)*3.28
# if the head height is zero or less there is no outflow
if(H <= 0){
outflow[d] = 0
###################################################
# Calculate new total nutrient amounts of N and P #
###################################################
# Since the outflow is zero there is no loss of P or N
# set the new initial total nutrients
P.tot[d] = i.P.tot
N.tot[d] = i.N.tot
# new initial total nutrient and initial nutrient concentrations don't
# change so there isn't a need to change the variables i.P.conc, i.N.conc
# Set new initial volume (same as before since there is no outflow)
i.vol = peak.vol[d]
# Set next day Water level
nd.vol[d] = peak.vol[d]
# Set new initial WL (same as before since there is no outflow)
nd.WL[d] = peak.WL[d]
} else {
# Calculate the outflow in cubic feet per day. The equation is in
# cubic feet per second, the 86400 are the number of seconds in a day
# Convert to meters cubed (0.0283168466 ft^3 = 1m^3)
pot.flow = ((3.33*(L - 0.2*H)*H^(2/3))*86400)*0.0283168466
# calculate the minimum volume allowed in the wetland beacuse of
# the planks.
vol.min = WLvsVol$vol[which(p.H == WLvsVol$WLs)]
# calculate max amount of water that can leave the system
out.max = peak.vol[d] - vol.min
if(out.max > pot.flow){
logic.flow[d] = T
# In the case that there is more water in the wetland
# that can flow out at the rate of pot.flow
outflow[d] = pot.flow
# Calculate the outflow rate for this time step
delta[d] = outflow[d]/peak.vol[d]
# calculate the next day's water volume by subtracting
# out the the total that can flow out.
nd.vol[d] = vol.min + (out.max-pot.flow)
###################################################
# Calculate new total nutrient amounts of N and P #
###################################################
# Calculate the total amount of nutrients that have left
# the wetland as a result of the outflow
nd.P.tot[d] = i.P.tot - outflow[d]*P.conc[d]
nd.N.tot[d] = i.N.tot - outflow[d]*N.conc[d]
# calculate the next day's P concentration
nd.P.conc[d] = nd.P.tot[d]/nd.vol[d]
nd.N.conc[d] = nd.N.tot[d]/nd.vol[d]
# Calculate the new water volume after all potential water
# has flowed out.
i.vol = nd.vol[d]
} else {
# In the case that more water can flow out of the weir
# in a day than is allowed or pot.flow > out.max
outflow[d] = out.max
# calculate the dilution rate (proportion flowing out)
delta[d] = outflow[d]/peak.vol[d]
# Set the "next day" water volume
nd.vol[d] = vol.min
###################################################
# Calculate new total nutrient amounts of N and P #
###################################################
# Calculate the total amount of nutrients that have left
# the wetland as a result of the outflow
nd.P.tot[d] = i.P.tot - outflow[d]*P.conc[d]
nd.N.tot[d] = i.N.tot - outflow[d]*N.conc[d]
# calculate the next day's P concentration
nd.P.conc[d] = nd.P.tot[d]/nd.vol[d]
nd.N.conc[d] = nd.N.tot[d]/nd.vol[d]
# set the new initial water volume for the wetland
i.vol = nd.vol[d]
}
# set the next day's water volume
nd.WL[d] = WLvsVol$WLs[which.min(i.vol >= WLvsVol$vol)]
}
#####################################
} else { # For the case when there is no WCS #
#####################################
# vector value that matches peak volume
# with the WL in the wetland
pWL.vec = which.min(peak.vol[d] >= WLvsVol$vol)
# find the peak Water level using the vector value.
peak.WL[d] = WLvsVol$WLs[pWL.vec]
# WL at Dorr Road doesn't go below 74.38
if (site.abv == "DR" && nd.WL[d] <= 74.38){
nd.WL[d] = 74.38
}
# PT is essentially part of the St. Lawrence River
# so the WL at PT is the same as ABay.
if (site.abv == "PT"){
nd.WL[d] = round(ABay.WL$IGLD.m[d], 3)
}
# find the next day's wetland water volume
nd.vol[d] = WLvsVol$vol[which(nd.WL[d+1] == WLvsVol$WLs)]
# calculate the outflow, the total amount of water that
# has flowed out of the wetland
outflow[d] = peak.vol[d] - nd.vol[d]
# calculate the dilution rate
delta[d] = outflow[d]/peak.vol[d]
###################################################
# Calculate new total nutrient amounts of N and P #
###################################################
if(delta[d] > 0){
# Calculate the total amount of water that has flowed out
w.outflux[d] = outflow[d] + iw.outflux
# The total amount of nutrient that has been exported
# out of the system at time step "d"
P.outflow[d] = outflow[d] * P.conc[d]
N.outflow[d] = outflow[d] * N.conc[d]
# Calculate the amount of nutrient P left in the system
# at time "d+1" or the next days total nutrient.
nd.P.tot[d] = P.tot[d] - P.outflow[d]
nd.N.tot[d] = N.tot[d] - N.outflow[d]
# calculate the total amount of nutrient that has been
# exported from the wetland.
P.tot.exp[d] = iP.tot.exp + P.outflow[d]
N.tot.exp[d] = iN.tot.exp + N.outflow[d]
# set a new initial total amount of P exported from the
# system.
iP.tot.exp = P.tot.exp[d]
iN.tot.exp = N.tot.exp[d]
# calculate the concentration of total nutrients exported
# from the wetland
P.exp.conc[d] = P.tot.exp[d]/w.outflux[d]
N.exp.conc[d] = N.tot.exp[d]/w.outflux[d]
# set the new initial total nutrient amount so that
# calculations can be made for the next time step.
i.P.tot = nd.P.tot[d]
i.N.tot = nd.N.tot[d]
# set a new initial total amount of water outflow value
iw.outflux = w.outflux[d]
} else { # When delta is negative assume there is
# a back flow back into the wetland from
# the main creek
# Calculate the total amount of water that flows back
# into the wetland from the creek
# (This should be outflow)
w.influx[d] = nd.vol[d] - peak.vol[d]
# Calculate the total amount of nutrients that are
# flowing back in from the creek into the wetland
if ((d-1) == 0) {
# for cases when the first day there is a negative outflow
P.influx[d] = 0
N.influx[d] = 0
} else {
# calculate the influx of total nutrients (N and P)
# multiply the nutrient concentration by total volume
# of water that has flowed back into the wetland
P.influx[d] = w.influx[d]*P.exp.conc[d]
N.influx[d] = w.influx[d]*N.exp.conc[d]
}
# Add the imported about of nutrients from the back flow
# to the total nutrient amount for this time step.
nd.P.tot[d] = P.influx[d] + i.P.tot
nd.N.tot[d] = P.influx[d] + i.N.tot
# calculate the nutrient concentration after an export event
nd.P.conc[d] = nd.P.tot[d]/nd.vol[d]
nd.N.conc[d] = nd.N.tot[d]/nd.vol[d]
# set the new initial total nutrient amount so that
# calculations can be made for the next time step.
i.P.tot = nd.P.tot[d]
i.N.tot = nd.N.tot[d]
}
# set the next day's "starting" water level
s.WL[d+1] = nd.WL[d]
# set a new initial volume
i.vol = nd.vol[d]
}
}
# calculate concentrations of nutrients in micromoles per liter
P.conc = P.conc/m3.to.L*kg.to.g/P.MM*M.to.uM
N.conc = N.conc/m3.to.L*kg.to.g/P.MM*M.to.uM
P.GWLF.conc = round(TP.kg/Daily.inflow/m3.to.L*kg.to.g/P.MM*M.to.uM, digits = 3)
N.GWLF.conc = round(TN.kg/Daily.inflow/m3.to.L*kg.to.g/P.MM*M.to.uM, digits = 3)
P.GWLF.conc = round(TP.kg/peak.vol/m3.to.L*kg.to.g/P.MM*M.to.uM, digits = 3)
N.GWLF.conc = round(TN.kg/peak.vol/m3.to.L*kg.to.g/P.MM*M.to.uM, digits = 3)
plot(N.conc, N.GWLF.conc)
plot(P.conc, P.GWLF.conc)
lines(x, y, col = 2)
x = 0:1000
y = x
lines(x, y, col = 2)
site.name
